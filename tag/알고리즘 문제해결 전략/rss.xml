<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>sohnjunior.github.io/</title>
   
   <link>http://localhost:4000</link>
   <description>PS와 웹 개발 관련내용을 기록합니다.</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>ALGOSPOT 변화하는 중간 값</title>
	  <link>//apss-runningmedian</link>
	  <author></author>
	  <pubDate>2020-07-24T00:00:00+09:00</pubDate>
	  <guid>//apss-runningmedian</guid>
	  <description><![CDATA[
	     <h2 id="풀이-과정">풀이 과정</h2>

<p>난수 생성기를 통해 각 입력이 주어질때마다 수열의 중간 값을 구해서 그 합을 구하는 문제입니다. <br />
이를 위해 생성되는 수열 <code class="highlighter-rouge">S</code> 를 두 구간으로 나눠서 생각하도록 합니다. <br />
정렬된 수열 <code class="highlighter-rouge">S</code> 를 나열했을 때 앞의 절반을 <code class="highlighter-rouge">최대 힙</code> 에 넣고 뒤에 절반을 <code class="highlighter-rouge">최소 힙</code> 에 넣으면 됩니다. <br />
중간값을 찾기 위한 규칙으로서 <code class="highlighter-rouge">최대 힙</code> 은 <code class="highlighter-rouge">최소 힙</code> 보다 작거나 같은 값을 가져야 하도록 하고 <br />
<code class="highlighter-rouge">최대 힙</code> 의 크기는 <code class="highlighter-rouge">최소 힙</code> 의 크기보다 1개 크거나 같게 한다면 중간 값은 항상 <code class="highlighter-rouge">최대 힙의 top</code> 이 됩니다. <br /></p>

<h2 id="코드">코드</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">heapq</span>


<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">max_pq</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">min_pq</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">rand</span> <span class="o">=</span> <span class="mi">1983</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="c"># 최대힙이 비어있거나 같거나 작은 값이 들어오는 경우</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">max_pq</span> <span class="ow">or</span> <span class="o">-</span><span class="n">max_pq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">rand</span><span class="p">:</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">max_pq</span><span class="p">,</span> <span class="o">-</span><span class="n">rand</span><span class="p">)</span>
        <span class="c"># 그 외의 경우에는 최소힙에 넣어줍니다</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">min_pq</span><span class="p">,</span> <span class="n">rand</span><span class="p">)</span>

        <span class="c"># 최대힙이 최소힙보다 1개 많거나 같다는 조건을 어길 경우 재조정해줍니다.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_pq</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">min_pq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">min_pq</span><span class="p">,</span> <span class="o">-</span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">max_pq</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">min_pq</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_pq</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">max_pq</span><span class="p">,</span> <span class="o">-</span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">min_pq</span><span class="p">))</span>

        <span class="n">rand</span> <span class="o">=</span> <span class="p">(</span><span class="n">rand</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">%</span> <span class="mi">20090711</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">(</span><span class="n">ans</span> <span class="o">+</span> <span class="o">-</span><span class="n">max_pq</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">%</span> <span class="mi">20090711</span>

    <span class="k">return</span> <span class="n">ans</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">T</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
        <span class="n">N</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">solution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>

</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>ALGOSPOT 요새</title>
	  <link>//apss-fortress</link>
	  <author></author>
	  <pubDate>2020-07-23T00:00:00+09:00</pubDate>
	  <guid>//apss-fortress</guid>
	  <description><![CDATA[
	     <h2 id="풀이-과정">풀이 과정</h2>

<p>각 요새의 성벽을 트리의 노드라고 한다면 문제에서 요구하는 답은 가장 거리가 먼 두 노드 사이의 거리값을 찾는 문제가 됩니다. <br />
따라서 각 원 사이의 거리 관계를 기준으로 포함 관계를 파악한 뒤, 트리를 형성해줍니다. <br />
트리에서 거리값이 가장 먼 두 노드 사이의 거리를 구하기 위해서는 전역 변수 <code class="highlighter-rouge">longest</code> 를 유지하며 트리의 높이를 구함과 동시에 <code class="highlighter-rouge">잎 - 잎 노드 사이의 거리 최대값</code> 을 구합니다.<br />
최종적으로 <code class="highlighter-rouge">트리의 높이</code> 와 <code class="highlighter-rouge">잎-잎 노드 사이의 거리 최대값</code> 중 더 큰 값이 두 노드 사이의 거리의 최대값이 됩니다. <br /></p>

<h2 id="코드">코드</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="nn">sys</span>


<span class="n">longest</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">walls</span> <span class="o">=</span> <span class="p">[]</span>


<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child</span> <span class="o">=</span> <span class="p">[]</span>


<span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">walls</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">walls</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">walls</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">walls</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>


<span class="k">def</span> <span class="nf">include</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">walls</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">walls</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="n">dist</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">walls</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">walls</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>


<span class="k">def</span> <span class="nf">is_child</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">include</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">walls</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">parent</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">child</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">include</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="ow">and</span> <span class="n">include</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>

    <span class="k">return</span> <span class="bp">True</span>


<span class="k">def</span> <span class="nf">make_tree</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">walls</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">is_child</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">child</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">make_tree</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">height</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">longest</span>

    <span class="c"># 자식들 중에서 가장 높이값이 큰 2개를 고른다</span>
    <span class="n">heights</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">child</span><span class="p">:</span>
        <span class="n">heights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">height</span><span class="p">(</span><span class="n">child</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">heights</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">heights</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">heights</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">longest</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">longest</span><span class="p">,</span> <span class="n">heights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">heights</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">heights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">solution</span><span class="p">():</span>
    <span class="c"># 트리를 생성합니다.</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">make_tree</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c"># 트리의 가장 긴 경로를 구합니다.</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">height</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">longest</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">T</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
        <span class="n">walls</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>

        <span class="n">longest</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">solution</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>

</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>ALGOSPOT 트리 순회 순서 변경</title>
	  <link>//apss-traversal</link>
	  <author></author>
	  <pubDate>2020-07-19T00:00:00+09:00</pubDate>
	  <guid>//apss-traversal</guid>
	  <description><![CDATA[
	     <h2 id="풀이-과정">풀이 과정</h2>

<p>트리의 중위 순회와 전위 순회 결과가 주어질 때, 이를 기반으로 후위 순회 결과를 만드는 문제입니다. <br />
우선 전위 순회의 결과에서 가장 앞에 있는 요소는 해당 트리의 루트 노드라는 사실을 알 수 있습니다. <br />
또한 중위 순회는 <code class="highlighter-rouge">왼쪽 서브트리 -&gt; 루트노드 -&gt; 오른쪽 서브트리</code> 순으로 순회를 하기 때문에 <br />
중위 순회 결과에서 루트 노드를 찾으면 그 양옆의 결과가 각각 <code class="highlighter-rouge">왼쪽 서브트리</code> 와 <code class="highlighter-rouge">오른쪽 서브트리</code> 의 순회 결과라는 사실을 알 수 있습니다.<br />
이를 통해 각 서브트리 노드의 개수를 알 수 있으므로 이를 전위 순회 결과에서 각 서브트리의 크기 만큼 배열을 잘라내면 잘려진 배열의 맨 앞 요소가 또한 각 서브트리의 루트 노드가 됩니다. <br />
이 과정을 재귀적으로 반복하면 우리가 찾는 <code class="highlighter-rouge">후위 순회</code> 결과를 얻을 수 있습니다.</p>

<h2 id="코드">코드</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="nn">sys</span>


<span class="k">def</span> <span class="nf">post_order</span><span class="p">(</span><span class="n">pre_order</span><span class="p">,</span> <span class="n">in_order</span><span class="p">,</span> <span class="n">ans</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pre_order</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">root</span> <span class="o">=</span> <span class="n">pre_order</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">left_count</span> <span class="o">=</span> <span class="n">in_order</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

    <span class="n">post_order</span><span class="p">(</span><span class="n">pre_order</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">left_count</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">in_order</span><span class="p">[:</span><span class="n">left_count</span><span class="p">],</span> <span class="n">ans</span><span class="p">)</span>
    <span class="n">post_order</span><span class="p">(</span><span class="n">pre_order</span><span class="p">[</span><span class="n">left_count</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="n">in_order</span><span class="p">[</span><span class="n">left_count</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="n">ans</span><span class="p">)</span>

    <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">pre_order</span><span class="p">,</span> <span class="n">in_order</span><span class="p">):</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">post_order</span><span class="p">(</span><span class="n">pre_order</span><span class="p">,</span> <span class="n">in_order</span><span class="p">,</span> <span class="n">ans</span><span class="p">)</span>
    <span class="k">return</span> <span class="s">' '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">ans</span><span class="p">))</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">T</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
        <span class="n">preorder</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
        <span class="n">inorder</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
        <span class="k">print</span><span class="p">(</span><span class="n">solution</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="n">inorder</span><span class="p">))</span>

</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>ALGOSPOT 외계 신호 분석</title>
	  <link>//apss-ites</link>
	  <author></author>
	  <pubDate>2020-07-15T00:00:00+09:00</pubDate>
	  <guid>//apss-ites</guid>
	  <description><![CDATA[
	     <h2 id="풀이-과정">풀이 과정</h2>

<p>입력으로 주어지는 데이터가 메모리 제한을 넘기기 때문에 입력값을 그때그때 생성하는 <code class="highlighter-rouge">온라인 알고리즘</code> 을 적용해야 풀 수 있는 문제입니다. <br />
모든 신호가 양의 정수이고 연속된 구간이 특정 양의 정수 <code class="highlighter-rouge">K</code> 를 만족해야 한다는 점을 이용하면 이 문제를 <code class="highlighter-rouge">deque</code> 를 사용해 효율적으로 풀 수 있음을 짐작할 수 있습니다. <br /></p>

<p>한 예로 <code class="highlighter-rouge">K = 5</code> 일때 다음과 같은 수열이 존재한다고 한다면, <br /></p>

<p>2, 3, 4, 5, 4, 3</p>

<p>연속된 구간에서 합이 5인 부분 수열은 <code class="highlighter-rouge">{2, 3}, {5}</code> 뿐 임을 알 수 있죠. <br />
이때 <code class="highlighter-rouge">{2, 3}</code> 에서 정수 <code class="highlighter-rouge">4</code> 가 추가되었을 경우 <code class="highlighter-rouge">K</code> 보다 커지기 때문에 유일한 방법은 맨 앞의 원소를 합이 <code class="highlighter-rouge">K</code> 보다 작아질때까지 하나씩 빼보는 것입니다. <br />
따라서 이러한 연산을 수행하기에는 <code class="highlighter-rouge">deque</code> 가 가장 적합하며 문제에서 주어진 난수 생성 방법을 통해 입력값을 만들어서 문제를 해결할 수 있습니다. <br /></p>

<h2 id="코드">코드</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>


<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">signal_sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">seed</span> <span class="o">=</span> <span class="mi">1983</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

    <span class="c"># 외계 신호는 총 N 개 생성된다.</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">current</span> <span class="o">=</span> <span class="p">(</span><span class="n">seed</span> <span class="o">%</span> <span class="mi">10000</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="p">(</span><span class="n">seed</span> <span class="o">*</span> <span class="mi">214013</span> <span class="o">+</span> <span class="mi">2531011</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">32</span><span class="p">)</span>

        <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
        <span class="n">signal_sum</span> <span class="o">+=</span> <span class="n">current</span>

        <span class="k">if</span> <span class="n">signal_sum</span> <span class="o">&gt;=</span> <span class="n">K</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">signal_sum</span> <span class="o">&gt;</span> <span class="n">K</span><span class="p">:</span>
                <span class="n">signal_sum</span> <span class="o">-=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">signal_sum</span> <span class="o">==</span> <span class="n">K</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">count</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">T</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
        <span class="n">K</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">solution</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>

</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>ALGOSPOT 조세푸스 문제</title>
	  <link>//apss-josephus</link>
	  <author></author>
	  <pubDate>2020-07-14T00:00:00+09:00</pubDate>
	  <guid>//apss-josephus</guid>
	  <description><![CDATA[
	     <h2 id="풀이-과정">풀이 과정</h2>

<p><code class="highlighter-rouge">연결 리스트</code> 를 활용한 유명한 문제중 하나인 조세푸스 문제입니다. <br />
Python의 경우 내장된 <code class="highlighter-rouge">list</code> 가 연결 리스트의 기능을 포함하고 있어서 이를 활용하였습니다. <br />
각 병사들이 원형으로 둘러싸여 있기 때문에 환형 리스트 연산이 필요하여 <code class="highlighter-rouge">모듈러 연산</code> 을 사용해서 인덱스를 계산해줬습니다. <br /></p>

<h2 id="코드">코드</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="nn">sys</span>


<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
    <span class="n">soilders</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>

    <span class="n">kill</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">soilders</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">soilders</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">kill</span><span class="p">)</span>

        <span class="n">kill</span> <span class="o">+=</span> <span class="p">(</span><span class="n">K</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">kill</span> <span class="o">%=</span> <span class="nb">len</span><span class="p">(</span><span class="n">soilders</span><span class="p">)</span>

    <span class="k">return</span> <span class="s">' '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">soilders</span><span class="p">))</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">T</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
        <span class="n">N</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">solution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>

</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>비트마스크 활용 방법 with Python</title>
	  <link>//apss-bitmask</link>
	  <author></author>
	  <pubDate>2020-07-07T00:00:00+09:00</pubDate>
	  <guid>//apss-bitmask</guid>
	  <description><![CDATA[
	     <h2 id="비트마스크란">비트마스크란?</h2>

<p>비트마스크는 정수의 이진수 표현을 자료구조로 활용하는 기법입니다. <br />
따라서 더 적은 메모리와 간결한 코드로 최적화를 할 수 있으며 비트 관련 연산은 대부분 상수 시간에 처리가 되기 때문에 더 빠른 속도를 기대할 수 있습니다. <br /></p>

<h2 id="활용-방법">활용 방법</h2>

<p>비트마스크를 사용하기 위해서는 우선 표현하고자 하는 상태를 이진수로 나타낼 수 있는 방법이 필요합니다. <br />
가장 대표적으로 집합을 비트마스크로 표현할 수 있습니다. <br /></p>

<h3 id="상태의-표현">상태의 표현</h3>

<p>예를 들어, 집합 <code class="highlighter-rouge">S = {1, 2, 3, 4, 5}</code> 가 존재한다고 하며 이를 비트로 표현해주기 위해서는 각 숫자를 하니의 자리수에 매핑할 수 있습니다. <br /></p>

<p>{5, 4, 3, 2, 1, x}
1 1 1 1 1 0 =&gt; 2^1 + 2^2 + 2^3 + 2^4 + 2^5 의 값으로 표현이 가능하다.</p>

<h2 id="비트-연산">비트 연산</h2>

<p>단순히 상태를 표현하는 것에 그치지 않고 우리는 이를 적절히 변형하고 원하는 정보를 직관적인 자료구조를 사용하는 것에 못지 않도록 하는 방법이 필요합니다. 비트 마스크는 <code class="highlighter-rouge">비트 연산자</code> 를 통해서 원하는 정보에 접근하고 변형을 할 수 있는 방법을 제시합니다.<br /></p>

<h3 id="공집합과-꽉찬-집합">공집합과 꽉찬 집합</h3>

<p>앞선 예시에서 <code class="highlighter-rouge">S = {1, 2, 3, 4, 5}</code> 의 경우 0번째 비트를 제외하면 전부 1 이었습니다. <br />
<code class="highlighter-rouge">&lt;&lt;</code> 연산자를 5번 사용해서 해당 집합을 만들 수도 있지만 이번에는 <code class="highlighter-rouge">꽉찬 집합</code> 을 사용해보겠습니다. <br />
우선 공집합은 <code class="highlighter-rouge">모든 비트가 0</code> 이기 때문에 <code class="highlighter-rouge">0</code> 과 같다는 사실은 자명합니다. <br /></p>

<p>꽉찬 집합의 경우 다음과 같은 코드로 생성할 수 있습니다. <br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">full</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c"># 11111</span>
</code></pre></div></div>

<p>동작 원리는 다음과 같습니다. <br /></p>

<ul>
  <li>(1 « 5) 에 의해 <code class="highlighter-rouge">100000</code> 가 생성됩니다. (하위 5개 비트가 0인 정수가 생성됨)</li>
  <li>1을 빼기 때문에 비트간 뺄셈 연산으로 <code class="highlighter-rouge">11111</code> 이 생성됩니다.</li>
</ul>

<p>따라서 앞선 <code class="highlighter-rouge">S = {1, 2, 3, 4, 5}</code> 를 <code class="highlighter-rouge">11110</code> 로 표현하기 위해서는 다음과 같이 나타낼 수 있을 것입니다. <br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">S</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c"># 11110</span>
</code></pre></div></div>

<h3 id="원소-추가">원소 추가</h3>

<p>원소 추가는 <code class="highlighter-rouge">|</code> 연산자를 활용합니다.(비트 연산 결과 둘 중 하나만 1이면 1이기 때문에) <br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span>  <span class="c"># 1010</span>
</code></pre></div></div>

<h3 id="원소-포함-여부">원소 포함 여부</h3>

<p>원소 포함 여부는 <code class="highlighter-rouge">&amp;</code> 연산자를 활용합니다.(비트 연산 결과 둘 다 1일 때만 1이기 때문에) <br />
이때 주의할 점은 <code class="highlighter-rouge">&amp;</code> 연산 결과 존재하지 않으면 <code class="highlighter-rouge">0</code> , 존재할 경우는 <code class="highlighter-rouge">&amp;</code> 연산 결과가 반환된다는 것입니다. (1이 아니다!) <br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span>  <span class="c"># 1000</span>
<span class="n">Ss</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span>  <span class="c"># 0</span>
</code></pre></div></div>

<h3 id="원소-삭제">원소 삭제</h3>

<p>원소 삭제의 경우 약간 까다로운데 이번에는 <code class="highlighter-rouge">&amp;</code> 와 <code class="highlighter-rouge">~</code> 연산자를 함께 사용합니다. <br />
삭제 대상에 해당하는 원소가 존재하지 않는 경우에도 문제없이 동작하는 코드를 위해 다음과 같이 구현할 수 있습니다. <br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">S</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span>  <span class="c"># 000</span>
</code></pre></div></div>

<p>만약 그냥 1을 빼버리면 어떻게 될까요? <br />
한번 예시를 들어 결과를 확인해보겠습니다. <br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span>  <span class="c"># 010 이 나오므로 잘못된 결과!</span>
</code></pre></div></div>

<p>이 경우 비트 뺄셈 연산에 의해 <code class="highlighter-rouge">010</code> 이라는 잘못된 결과를 돌려주는 것을 확인할 수 있습니다. <br /></p>

<h3 id="원소-토글">원소 토글</h3>

<p>특정 비트의 현재 값이 0일 경우 1로, 1일 경우 0으로 바꿔주는 연산이 필요할 수 있습니다. <br />
이때는 <code class="highlighter-rouge">^</code> 연산자를 통해 <code class="highlighter-rouge">XOR</code> 연산을 수행하면 원하는 결과를 얻을 수 있습니다. <br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c"># 111</span>
<span class="n">S</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span>  <span class="c"># 101</span>
</code></pre></div></div>

<h3 id="원소의-개수-구하기">원소의 개수 구하기</h3>

<p>원소의 개수는 비트 중 1의 개수를 세어주면 됩니다. <br />
Python의 경우 다음과 같은 코드로 쉽게 구할 수 있습니다. <br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="k">print</span><span class="p">(</span><span class="nb">bin</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">'1'</span><span class="p">))</span>  <span class="c"># 3</span>
</code></pre></div></div>

<h3 id="모든-부분-집합-생성하기">모든 부분 집합 생성하기</h3>

<p>비트마스크를 사용하면 모든 부분집합을 쉽게 구할 수 있습니다. <br />
<code class="highlighter-rouge">S = {사과, 배, 복숭아}</code> 의 집합의 부분 집합의 개수는 총 2^3 = 8 개일 것입니다. <br />
위 집합의 부분집합을 다음과 같은 코드로 생성할 수 있습니다. <br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">S</span> <span class="o">=</span> <span class="p">[</span><span class="s">'사과'</span><span class="p">,</span> <span class="s">'배'</span><span class="p">,</span> <span class="s">'복숭아'</span><span class="p">]</span>

<span class="c"># 각 상태를 비트로 표현해준다.</span>
<span class="c"># 사과 : 001</span>
<span class="c"># 배 : 010</span>
<span class="c"># 복숭아 : 100</span>
<span class="n">masks</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">))]</span>

<span class="c"># 모든 부분집합을 생성한다. (000 ~ 111)</span>
<span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">masks</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">subset</span><span class="p">:</span>
            <span class="n">answer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
    <span class="k">print</span><span class="p">(</span><span class="n">answer</span><span class="p">)</span>

</code></pre></div></div>

<p>유심히 봐야하는 부분은 <code class="highlighter-rouge">masks</code> 를 생성하는 것과 모든 부분집합을 생성하는 <code class="highlighter-rouge">range(1 &lt;&lt; len(S))</code> 입니다. <br />
<code class="highlighter-rouge">range(1 &lt;&lt; len(S))</code> 는 사실 <code class="highlighter-rouge">0 ~ 1 &lt;&lt; len(S) - 1</code> 과 동일한 것이며 이는 <code class="highlighter-rouge">S</code> 의 길이가 3일 때 <code class="highlighter-rouge">000 ~ 111</code> 까지 모든 집합을 방문하게 됩니다. <br />
각각의 집합에 표현되어 있는 실제 상태를 추출하기 위해 <code class="highlighter-rouge">&amp;</code> 연산자로 포함 여부를 검사하였고 이를 출력해주도록 하였습니다. <br /></p>

<h2 id="활용-예시">활용 예시</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="c"># 3개의 토핑을 가진 피자 생성</span>
<span class="n">fullPizza</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c"># 111</span>

<span class="c"># 토핑 개수 출력 (집합의 크기 구하기)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">bin</span><span class="p">(</span><span class="n">fullPizza</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">'1'</span><span class="p">))</span>  <span class="c"># 1이 3개 있으므로 3 출력</span>

<span class="c"># 새로운 토핑 추가</span>
<span class="n">fullPizza</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">bin</span><span class="p">(</span><span class="n">fullPizza</span><span class="p">))</span>  <span class="c"># 10111</span>

<span class="c"># 토핑이 제대로 추가되었는지 확인하자 (주의! 토핑이 있다면 (1 &lt;&lt; 4), 없으면 0을 반환합니다)</span>
<span class="k">if</span> <span class="n">fullPizza</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'토핑이 추가되었습니다'</span><span class="p">)</span>  <span class="c"># 토핑이 존재하므로 출력됩니다.</span>

<span class="c"># 오래된 두번째 토핑을 제거합니다.</span>
<span class="n">fullPizza</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">bin</span><span class="p">(</span><span class="n">fullPizza</span><span class="p">))</span>  <span class="c"># 10101</span>

<span class="c"># 네번째 토핑이 존재하면 제거하고 만약 없다면 새로 추가합니다. (토글)</span>
<span class="n">fullPizza</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">bin</span><span class="p">(</span><span class="n">fullPizza</span><span class="p">))</span>  <span class="c"># 11101</span>

<span class="c"># 최소 원소 지우기</span>
<span class="n">fullPizza</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">fullPizza</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">bin</span><span class="p">(</span><span class="n">fullPizza</span><span class="p">))</span>  <span class="c"># 11100</span>

<span class="c"># 모든 부분 집합 순회하기</span>
<span class="s">"""
아래와 같은 순서로 출력됩니다.
0b0
0b1
0b10
0b11
0b100
0b101
0b110
0b111
"""</span>
<span class="k">print</span><span class="p">(</span><span class="s">"subset!!"</span><span class="p">)</span>
<span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">bin</span><span class="p">(</span><span class="n">subset</span><span class="p">))</span>

</code></pre></div></div>

<h2 id="참고자료">참고자료</h2>

<ul>
  <li>https://stackoverflow.com/questions/9829578/fast-way-of-counting-non-zero-bits-in-positive-integer</li>
  <li>https://blog.naver.com/PostView.nhn?blogId=kmh03214&amp;logNo=221702095617&amp;parentCategoryNo=&amp;categoryNo=23&amp;viewDate=&amp;isShowPopularPosts=true&amp;from=search</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>KMP 알고리즘 구현 with Python</title>
	  <link>//apss-kmp</link>
	  <author></author>
	  <pubDate>2020-07-06T00:00:00+09:00</pubDate>
	  <guid>//apss-kmp</guid>
	  <description><![CDATA[
	     <h2 id="풀이-과정">풀이 과정</h2>

<p><code class="highlighter-rouge">KMP 알고리즘</code> 은 주어진 짚더미 문자열 <code class="highlighter-rouge">H</code> 내에서 바늘 문자열 <code class="highlighter-rouge">N</code> 을 찾는 효율적인 알고리즘입니다. <br />
알고리즘의 동작 방식에 대한 설명은 저자의 책을 참고하고, C++ 로 구현되어 있는 것을 Python으로 따로 구현해봤습니다. <br /></p>

<h2 id="코드">코드</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="c"># 부분 일치 테이블 생성</span>
<span class="k">def</span> <span class="nf">partial</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">ret</span><span class="p">,</span> <span class="n">matched</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">N</span><span class="p">))],</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">N</span><span class="p">)):</span>
        <span class="k">while</span> <span class="n">matched</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">N</span><span class="p">[</span><span class="n">matched</span><span class="p">]:</span>
            <span class="n">matched</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="n">matched</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">N</span><span class="p">[</span><span class="n">matched</span><span class="p">]:</span>
            <span class="n">matched</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">matched</span>

    <span class="k">return</span> <span class="n">ret</span>


<span class="c"># 생성된 부분 일치 테이블을 기반으로 kmp 수행</span>
<span class="k">def</span> <span class="nf">kmp</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="n">pi</span><span class="p">,</span> <span class="n">matched</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">H</span><span class="p">)):</span>
        <span class="k">while</span> <span class="n">matched</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">N</span><span class="p">[</span><span class="n">matched</span><span class="p">]:</span>
            <span class="n">matched</span> <span class="o">=</span> <span class="n">pi</span><span class="p">[</span><span class="n">matched</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">N</span><span class="p">[</span><span class="n">matched</span><span class="p">]:</span>
            <span class="n">matched</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">matched</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">matched</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c"># 일치 시작 지점을 저장한다.</span>
                <span class="n">matched</span> <span class="o">=</span> <span class="n">pi</span><span class="p">[</span><span class="n">matched</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">ret</span>


<span class="n">p1</span> <span class="o">=</span> <span class="s">"aab"</span>
<span class="n">t1</span> <span class="o">=</span> <span class="s">"aaabaacbaab"</span>
<span class="k">print</span><span class="p">(</span><span class="n">kmp</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">p1</span><span class="p">))</span>  <span class="c"># [1, 8]</span>


</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>ALGOSPOT 재하의 금고</title>
	  <link>//apss-jaehasafe</link>
	  <author></author>
	  <pubDate>2020-07-06T00:00:00+09:00</pubDate>
	  <guid>//apss-jaehasafe</guid>
	  <description><![CDATA[
	     <h2 id="풀이-과정">풀이 과정</h2>

<p>문자열 검색 알고리즘인 <code class="highlighter-rouge">KMP</code> 를 응용하여 환형 시프트 연산을 구현하는 문제입니다. <br />
원본 문자열 <code class="highlighter-rouge">H</code> 를 시계 방향 혹은 반시계 방향으로 shift한 문자열이 <code class="highlighter-rouge">N</code> 일 때, 그 횟수를 구하는 가장 간단한 방법은 <code class="highlighter-rouge">H(혹은 N) 에서 N(혹은 H) 를 찾는 것</code> 입니다.
이를 위해서 부분 일치 테이블과 kmp 알고리즘을 구현 한 뒤, 가장 처음 매칭되는 인덱스 값이 곧 필요한 이동 횟수이므로 이 값을 누적하여 계산하면 됩니다. <br /></p>

<h2 id="코드">코드</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="nn">sys</span>


<span class="k">def</span> <span class="nf">partial</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">pi</span><span class="p">,</span> <span class="n">matched</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">N</span><span class="p">)):</span>
        <span class="k">while</span> <span class="n">matched</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">N</span><span class="p">[</span><span class="n">matched</span><span class="p">]:</span>
            <span class="n">matched</span> <span class="o">=</span> <span class="n">pi</span><span class="p">[</span><span class="n">matched</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">N</span><span class="p">[</span><span class="n">matched</span><span class="p">]:</span>
            <span class="n">matched</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">pi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">matched</span>

    <span class="k">return</span> <span class="n">pi</span>


<span class="k">def</span> <span class="nf">kmp</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="n">pi</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">matched</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="p">[],</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">H</span><span class="p">)):</span>
        <span class="k">while</span> <span class="n">matched</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">N</span><span class="p">[</span><span class="n">matched</span><span class="p">]:</span>
            <span class="n">matched</span> <span class="o">=</span> <span class="n">pi</span><span class="p">[</span><span class="n">matched</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">N</span><span class="p">[</span><span class="n">matched</span><span class="p">]:</span>
            <span class="n">matched</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">matched</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">matched</span> <span class="o">=</span> <span class="n">pi</span><span class="p">[</span><span class="n">matched</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">ret</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">T</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
        <span class="n">before</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">after</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c"># 짝수 번째 - 반시계 방향</span>
                <span class="n">ans</span> <span class="o">+=</span> <span class="n">kmp</span><span class="p">(</span><span class="n">before</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">after</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># 홀수 번째 - 시계 방향</span>
                <span class="n">ans</span> <span class="o">+=</span> <span class="n">kmp</span><span class="p">(</span><span class="n">after</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">before</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">before</span> <span class="o">=</span> <span class="n">after</span>
        <span class="k">print</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>


</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>ALGOSPOT 선거 공약</title>
	  <link>//apss-promises</link>
	  <author></author>
	  <pubDate>2020-06-25T00:00:00+09:00</pubDate>
	  <guid>//apss-promises</guid>
	  <description><![CDATA[
	     <h2 id="문제">문제</h2>

<p><a href="https://algospot.com/judge/problem/read/PROMISES">알고스팟 - 선거 공약</a></p>

<h2 id="풀이-과정">풀이 과정</h2>

<p><code class="highlighter-rouge">플로이드 알고리즘</code> 을 활용하는 마지막 문제입니다. <br />
기존의 플로이드 알고리즘은 경유점을 하나씩 늘려가며 최단 거리를 갱신하는 방법을 사용합니다. <br />
하지만 여기서 경유점 대신에 그래프에 존재하는 모든 간선들을 하나씩 추가하며 최단 거리를 갱신하더라도 정당성은 변하지 않음을 알 수 있습니다. <br />
따라서 기존의 점화식을 다음과 같은 형태로 바꿔줍니다. <br /></p>

<blockquote>
  <p>D(A, B) = min(D’(A, B), D’(A, u) + D’(v, B) + w(u, v), D’(A, v) + D’(u, B) + w(v, u))</p>
</blockquote>

<p>이때 간선의 경우 정점과는 다르게 어느 방향으로 타고 가는지에 따라 값이 달라질 수 있으므로 위와 같이 3가지 상황을 고려해줘야 합니다. <br /></p>

<h2 id="코드">코드</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">INF</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span>
<span class="n">adj</span> <span class="o">=</span> <span class="p">[]</span>


<span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;=</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="p">):</span>
            <span class="n">adj</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">adj</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">],</span> <span class="n">adj</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">adj</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">+</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span>

    <span class="k">return</span> <span class="bp">True</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">T</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
        <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="p">[[</span><span class="n">INF</span><span class="p">]</span><span class="o">*</span><span class="n">V</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="p">)]</span>

        <span class="c"># 현재 존재하는 간선</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="n">frm</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
            <span class="n">adj</span><span class="p">[</span><span class="n">frm</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">to</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>
            <span class="n">adj</span><span class="p">[</span><span class="n">to</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">frm</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>

        <span class="c"># 자기 자신을 향하는 가중치는 0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="p">):</span>
            <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">frm</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">update</span><span class="p">(</span><span class="n">frm</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">to</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
                <span class="n">ans</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">print</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>

</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>ALGOSPOT 음주운전 단속</title>
	  <link>//apss-drunken</link>
	  <author></author>
	  <pubDate>2020-05-16T00:00:00+09:00</pubDate>
	  <guid>//apss-drunken</guid>
	  <description><![CDATA[
	     <h2 id="문제">문제</h2>

<p><a href="https://algospot.com/judge/problem/read/DRUNKEN">알고스팟 - 음주운전 단속</a></p>

<h2 id="풀이-과정">풀이 과정</h2>

<p>이 문제는 최악의 경우에도 시간이 가장 적게 걸리는 경로를 찾아야합니다. <br />
단순히 경로의 길이가 짧다고 해서 최단 경로라는 보장이 없으므로 정점을 하나씩 늘려가면서 음주 단속에 따른 지연시간도 고려해줘야합니다. <br />
따라서 음주 운전 단속 시간이 짦은 정점의 오름차순으로 경유지를 추가하면서 계산되는 최단 경로값을 이용해 최종 도달 가능 시간을 계산해야합니다. <br /></p>

<p>이를 위해서 다음과 같은 새로운 점화식을 추가합니다. <br /></p>

<blockquote>
  <p>W[u][v] = min(C[u][w] + C[w][v] + delay[w])</p>
</blockquote>

<p>여기서 <code class="highlighter-rouge">w</code> 는 경유점으로 각 지점을 오름차순으로 검사하므로 최악의 경우에 대해 최단 경로값을 계산할 수 있게됩니다. <br />
Python3 으로 제출해봤지만 도무지 시간 초과를 해결할 수 없어서 C++로 다시 풀어서 제출했습니다. <br /></p>

<h2 id="코드">코드</h2>

<h3 id="python">Python</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">INF</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span>
<span class="n">V</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
<span class="n">police</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))))</span>
<span class="n">police</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="n">adj</span> <span class="o">=</span> <span class="p">[[</span><span class="n">INF</span><span class="p">]</span> <span class="o">*</span> <span class="n">V</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
    <span class="n">frm</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
    <span class="n">adj</span><span class="p">[</span><span class="n">frm</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">to</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>
    <span class="n">adj</span><span class="p">[</span><span class="n">to</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">frm</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>

<span class="n">T</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
<span class="n">test_case</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
    <span class="n">test_case</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())))</span>


<span class="k">def</span> <span class="nf">floyd</span><span class="p">():</span>
    <span class="n">W</span> <span class="o">=</span> <span class="p">[[</span><span class="n">INF</span><span class="p">]</span><span class="o">*</span><span class="n">V</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
                <span class="n">W</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">W</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">delay</span> <span class="ow">in</span> <span class="n">police</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="p">):</span>
                    <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">],</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">adj</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">v</span><span class="p">])</span>
                    <span class="n">W</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">],</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">adj</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">+</span> <span class="n">delay</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">W</span>


<span class="k">def</span> <span class="nf">solution</span><span class="p">():</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">floyd</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">test_case</span><span class="p">:</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="n">test</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">test</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">print</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>


<span class="n">solution</span><span class="p">()</span>

</code></pre></div></div>

<h3 id="c">C++</h3>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="cp">#define INF 987654321
</span><span class="kt">int</span> <span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">adj</span><span class="p">[</span><span class="mi">500</span><span class="p">][</span><span class="mi">500</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">W</span><span class="p">[</span><span class="mi">500</span><span class="p">][</span><span class="mi">500</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">polices</span><span class="p">;</span>


<span class="kt">void</span> <span class="nf">floyd</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">order</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">order</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">polices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">));</span>
	<span class="n">sort</span><span class="p">(</span><span class="n">order</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">order</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span>
				<span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">order</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">second</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">order</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">u</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">],</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">+</span> <span class="n">adj</span><span class="p">[</span><span class="n">w</span><span class="p">][</span><span class="n">v</span><span class="p">]);</span>
				<span class="n">W</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">],</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">+</span> <span class="n">adj</span><span class="p">[</span><span class="n">w</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">+</span> <span class="n">delay</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">V</span> <span class="o">&gt;&gt;</span> <span class="n">E</span><span class="p">;</span>
	<span class="n">polices</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">polices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="n">fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adj</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">adj</span><span class="p">[</span><span class="mi">499</span><span class="p">][</span><span class="mi">500</span><span class="p">],</span> <span class="n">INF</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">E</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">frm</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">weight</span><span class="p">;</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">frm</span> <span class="o">&gt;&gt;</span> <span class="n">to</span> <span class="o">&gt;&gt;</span> <span class="n">weight</span><span class="p">;</span>

		<span class="n">adj</span><span class="p">[</span><span class="n">frm</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">to</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span><span class="p">;</span>
		<span class="n">adj</span><span class="p">[</span><span class="n">to</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">frm</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">floyd</span><span class="p">();</span>

	<span class="kt">int</span> <span class="n">T</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">T</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">test</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">test</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">;</span> <span class="n">test</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">end</span><span class="p">;</span>

		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">W</span><span class="p">[</span><span class="n">start</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">end</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="k">return</span>  <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

	  ]]></description>
	</item>


</channel>
</rss>
