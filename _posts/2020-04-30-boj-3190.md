---
layout: post
title: BOJ 3190 - 뱀
excerpt: "BOJ 3190 뱀 with Python"
categories: [Algorithm]
tags: [Algorithm]
modified: 2020-04-30
comments: true
---

## 출처
[백준 온라인 저지 - 3190번](https://www.acmicpc.net/problem/3190)


## 문제
'Dummy' 라는 도스게임이 있다. 이 게임에는 뱀이 나와서 기어다니는데, 사과를 먹으면 뱀 길이가 늘어난다. <br>
뱀이 이리저리 기어다니다가 벽 또는 자기자신의 몸과 부딪히면 게임이 끝난다.

게임은 NxN 정사각 보드위에서 진행되고, 몇몇 칸에는 사과가 놓여져 있다. 보드의 상하좌우 끝에 벽이 있다. <br>
게임이 시작할때 뱀은 맨위 맨좌측에 위치하고 뱀의 길이는 1 이다. 뱀은 처음에 오른쪽을 향한다.

뱀은 매 초마다 이동을 하는데 다음과 같은 규칙을 따른다.

* 먼저 뱀은 몸길이를 늘려 머리를 다음칸에 위치시킨다.
* 만약 이동한 칸에 사과가 있다면, 그 칸에 있던 사과가 없어지고 꼬리는 움직이지 않는다.
* 만약 이동한 칸에 사과가 없다면, 몸길이를 줄여서 꼬리가 위치한 칸을 비워준다. 즉, 몸길이는 변하지 않는다.

사과의 위치와 뱀의 이동경로가 주어질 때 이 게임이 몇 초에 끝나는지 계산하라.

## 입력
첫째 줄에 보드의 크기 N이 주어진다. 그 다음 줄에 사과의 개수 K가 주어진다. <br>

다음 K개의 줄에는 사과의 위치가 주어지는데, 첫 번째 정수는 행, 두 번째 정수는 열 위치를 의미한다. <br>
사과의 위치는 모두 다르며, 맨 위 맨 좌측 (1행 1열) 에는 사과가 없다. <br>

다음 줄에는 뱀의 방향 변환 횟수 L 이 주어진다.  <br>

다음 L개의 줄에는 뱀의 방향 변환 정보가 주어지는데, 정수 X와 문자 C로 이루어져 있으며 <br>
게임 시작 시간으로부터 X초가 끝난 뒤에 왼쪽(C가 'L') 또는 오른쪽(C가 'D')로 90도 방향을 회전시킨다는 뜻이다. <br>
X는 10,000 이하의 양의 정수이며, 방향 전환 정보는 X가 증가하는 순으로 주어진다.<br>

## 출력
첫째 줄에 게임이 몇 초에 끝나는지 출력한다.

## 풀이 과정
뱀 게임을 시뮬레이션해보는 문제이다. <br>
주의할 점은 N초 후에 회전을 한다는 것이 N+1 초에 회전된 위치로의 이동이 이루어진다는 의미이다. <br>
처음에 이것 때문에 계속 막혔었다..

### 게임판 설정
우선 뱀 게임 시뮬레이션을 위해 `(N+2)*(N+2)` 크기의 게임판 `board`를 선언하였다. <br>
문제 조건에서 가장자리는 벽으로 하고 게임 시작지점을 1행 1열로 하였으므로 구현의 편의성을 위해 가장자리를 추가한 것이다. <br>

또한 현재 게임판의 상태를 표현해주는 딕셔너리를 사용해서 직관적인 코드 작성을 꾀하였다.

### 뱀의 이동
가장 까다로운 부분은 뱀의 이동연산이다. <br>
이를 위해서는 현재 뱀의 위치와 바뀔 회전 방향을 고려해줘야 한다. <br>
또한 이동시 뱀의 꼬리도 따라와야 하므로 굉장히 복잡한 연산이 아닐수 없다..

우선 각 방향(동, 서, 남, 북)에 따른 왼쪽과 오른쪽 연산 결과를 처리해줘야 한다. <br>
현재 방향에 따라 왼쪽과 오른쪽 회전 결과는 다르기 때문에 이를 딕셔너리 자료형에 저장한 뒤 사용하였다. <br>

뱀의 이동을 구현하는 여러가지 방법이 있겠지만 나는 매 초마다 회전 연산 목록을 확인해주며 <br>
시간이 되었을 때 해당하는 회전 연산이 이루어지도록 하였다. <br>
또한 머리와 꼬리의 이동 방향을 각각 따로 유지하면서 회전 연산이 이루어졌을 경우 현재 위치와 다음 이동 방향을 큐에 저장해줬다. <br>
어차피 꼬리는 현재 방향을 기준으로 한 칸씩 이동하니까 만약 꼬리가 이전에 한번 꺾인 지점에 도달했을때 이전에 회전했던 방향으로 꼬리도 회전해주도록 하면 되는 것이다.

## 코드
~~~ python

import sys
from collections import deque


N = int(input())
K = int(input())
apples = []
for _ in range(K):
    apples.append(list(map(int, sys.stdin.readline().split())))
L = int(input())
rotate = []
for _ in range(L):
    line = list(sys.stdin.readline().split())
    rotate.append([int(line[0]), line[1]])


state = {
    'blank': 0,
    'wall': 1,
    'body': 2,
    'apple': 3,
}

# 현재 방향을 고려한 왼쪽과 오른쪽 이동시 다음 방향
next_rotate_dir = {
    'e': {'L': 'n', 'D': 's'},
    'w': {'L': 's', 'D': 'n'},
    's': {'L': 'e', 'D': 'w'},
    'n': {'L': 'w', 'D': 'e'},
}

# 동서남북 이동 좌표
move_pos = {
    'e': [0, 1],
    'w': [0, -1],
    's': [1, 0],
    'n': [-1, 0],
}

def solution():
    timer = 0
    dir = 'e'
    tail_dir = 'e'
    head = [1, 1]
    tail = [1, 1]
    board = [[0 for _ in range(N+2)] for _ in range(N+2)]
    rotate.reverse()

    rotate_log = deque()

    for i in range(N + 2):
        board[0][i] = 1
        board[i][0] = 1
        board[i][N+1] = 1
        board[N+1][i] = 1

    for apple in apples:
        board[apple[0]][apple[1]] = state['apple']

    board[1][1] = state['body']

    while True:
        # 변환 시간이 되면
        if rotate and timer == rotate[-1][0]:
            dir = next_rotate_dir[dir][rotate[-1][1]]
            rotate_log.append((head, dir))  # 변환 지점과 다음 방향을 로그에 저장
            rotate.pop()

        next_head = [head[0] + move_pos[dir][0], head[1] + move_pos[dir][1]]
        head = next_head

        # 자신의 몸 혹은 벽에 머리가 닿으면 종료
        if board[head[0]][head[1]] == state['wall'] or board[head[0]][head[1]] == state['body']:
            timer += 1
            break
        # 사과가 있다면
        elif board[head[0]][head[1]] == state['apple']:
            board[head[0]][head[1]] = state['body']
        # 사과가 없다면
        else:
            board[head[0]][head[1]] = state['body']
            board[tail[0]][tail[1]] = state['blank']

            # 다음 꼬리 위치 찾기
            # 현재 꼬리가 이전에 꺾인 지점이면
            if rotate_log and tail == rotate_log[0][0]:
                tail_dir = rotate_log[0][1]
                rotate_log.popleft()
            next_tail = [tail[0] + move_pos[tail_dir][0], tail[1] + move_pos[tail_dir][1]]
            tail = next_tail
        timer += 1

    return timer


print(solution())

~~~

