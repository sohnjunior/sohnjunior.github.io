---
layout: post
cover: "assets/images/cover2.jpg"
navigation: True
title: 비트마스크 활용 방법 with Python
date: 2020-07-07
tags: [알고리즘 문제해결 전략]
subclass: "post"
logo: "assets/images/ghost.png"
author: sohnjunior
categories: algorithm
comments: true
---

## 비트마스크란?

비트마스크는 정수의 이진수 표현을 자료구조로 활용하는 기법입니다. <br>
따라서 더 적은 메모리와 간결한 코드로 최적화를 할 수 있으며 비트 관련 연산은 대부분 상수 시간에 처리가 되기 때문에 더 빠른 속도를 기대할 수 있습니다. <br>

## 활용 방법

비트마스크를 사용하기 위해서는 우선 표현하고자 하는 상태를 이진수로 나타낼 수 있는 방법이 필요합니다. <br>
가장 대표적으로 집합을 비트마스크로 표현할 수 있습니다. <br>

### 상태의 표현

예를 들어, 집합 `S = {1, 2, 3, 4, 5}` 가 존재한다고 하며 이를 비트로 표현해주기 위해서는 각 숫자를 하니의 자리수에 매핑할 수 있습니다. <br>

{% raw %}
{5, 4, 3, 2, 1, x}
1 1 1 1 1 0 => 2^1 + 2^2 + 2^3 + 2^4 + 2^5 의 값으로 표현이 가능하다.
{% endraw %}

## 비트 연산

단순히 상태를 표현하는 것에 그치지 않고 우리는 이를 적절히 변형하고 원하는 정보를 직관적인 자료구조를 사용하는 것에 못지 않도록 하는 방법이 필요합니다. 비트 마스크는 `비트 연산자` 를 통해서 원하는 정보에 접근하고 변형을 할 수 있는 방법을 제시합니다.<br>

### 공집합과 꽉찬 집합

앞선 예시에서 `S = {1, 2, 3, 4, 5}` 의 경우 0번째 비트를 제외하면 전부 1 이었습니다. <br>
`<<` 연산자를 5번 사용해서 해당 집합을 만들 수도 있지만 이번에는 `꽉찬 집합` 을 사용해보겠습니다. <br>
우선 공집합은 `모든 비트가 0` 이기 때문에 `0` 과 같다는 사실은 자명합니다. <br>

꽉찬 집합의 경우 다음과 같은 코드로 생성할 수 있습니다. <br>

```python
full = (1 << 5) - 1  # 11111
```

동작 원리는 다음과 같습니다. <br>

- (1 << 5) 에 의해 `100000` 가 생성됩니다. (하위 5개 비트가 0인 정수가 생성됨)
- 1을 빼기 때문에 비트간 뺄셈 연산으로 `11111` 이 생성됩니다.

따라서 앞선 `S = {1, 2, 3, 4, 5}` 를 `11110` 로 표현하기 위해서는 다음과 같이 나타낼 수 있을 것입니다. <br>

```python
S = ((1 << 5) - 1) - 1  # 11110
```

### 원소 추가

원소 추가는 `|` 연산자를 활용합니다.(비트 연산 결과 둘 중 하나만 1이면 1이기 때문에) <br>

```python
S = (1 << 3) | (1 << 1)  # 1010
```

### 원소 포함 여부

원소 포함 여부는 `&` 연산자를 활용합니다.(비트 연산 결과 둘 다 1일 때만 1이기 때문에) <br>
이때 주의할 점은 `&` 연산 결과 존재하지 않으면 `0` , 존재할 경우는 `&` 연산 결과가 반환된다는 것입니다. (1이 아니다!) <br>

```python
S = (1 << 3) & (1 << 3)  # 1000
Ss = (1 << 3) & (1 << 1)  # 0
```

### 원소 삭제

원소 삭제의 경우 약간 까다로운데 이번에는 `&` 와 `~` 연산자를 함께 사용합니다. <br>
삭제 대상에 해당하는 원소가 존재하지 않는 경우에도 문제없이 동작하는 코드를 위해 다음과 같이 구현할 수 있습니다. <br>

```python
S = (1 << 2)
S &= ~(1 << 2)  # 000
```

만약 그냥 1을 빼버리면 어떻게 될까요? <br>
한번 예시를 들어 결과를 확인해보겠습니다. <br>

```python
S = (1 << 2) - (1 << 1)  # 010 이 나오므로 잘못된 결과!
```

이 경우 비트 뺄셈 연산에 의해 `010` 이라는 잘못된 결과를 돌려주는 것을 확인할 수 있습니다. <br>

### 원소 토글

특정 비트의 현재 값이 0일 경우 1로, 1일 경우 0으로 바꿔주는 연산이 필요할 수 있습니다. <br>
이때는 `^` 연산자를 통해 `XOR` 연산을 수행하면 원하는 결과를 얻을 수 있습니다. <br>

```python
S = (1 << 3) - 1  # 111
S ^= (1 << 1)  # 101
```

### 원소의 개수 구하기

원소의 개수는 비트 중 1의 개수를 세어주면 됩니다. <br>
Python의 경우 다음과 같은 코드로 쉽게 구할 수 있습니다. <br>

```python
S = (1 << 3) - 1
print(bin(S).count('1'))  # 3
```

### 모든 부분 집합 생성하기

비트마스크를 사용하면 모든 부분집합을 쉽게 구할 수 있습니다. <br>
`S = {사과, 배, 복숭아}` 의 집합의 부분 집합의 개수는 총 2^3 = 8 개일 것입니다. <br>
위 집합의 부분집합을 다음과 같은 코드로 생성할 수 있습니다. <br>

```python

S = ['사과', '배', '복숭아']

# 각 상태를 비트로 표현해준다.
# 사과 : 001
# 배 : 010
# 복숭아 : 100
masks = [1 << i for i in range(len(S))]

# 모든 부분집합을 생성한다. (000 ~ 111)
for subset in range(1 << len(S)):
    answer = []
    for idx, mask in enumerate(masks):
        if mask & subset:
            answer.append(S[idx])
    print(answer)

```

유심히 봐야하는 부분은 `masks` 를 생성하는 것과 모든 부분집합을 생성하는 `range(1 << len(S))` 입니다. <br>
`range(1 << len(S))` 는 사실 `0 ~ 1 << len(S) - 1` 과 동일한 것이며 이는 `S` 의 길이가 3일 때 `000 ~ 111` 까지 모든 집합을 방문하게 됩니다. <br>
각각의 집합에 표현되어 있는 실제 상태를 추출하기 위해 `&` 연산자로 포함 여부를 검사하였고 이를 출력해주도록 하였습니다. <br>

## 활용 예시

```python


# 3개의 토핑을 가진 피자 생성
fullPizza = (1 << 3) - 1  # 111

# 토핑 개수 출력 (집합의 크기 구하기)
print(bin(fullPizza).count('1'))  # 1이 3개 있으므로 3 출력

# 새로운 토핑 추가
fullPizza |= (1 << 4)
print(bin(fullPizza))  # 10111

# 토핑이 제대로 추가되었는지 확인하자 (주의! 토핑이 있다면 (1 << 4), 없으면 0을 반환합니다)
if fullPizza & (1 << 4):
    print('토핑이 추가되었습니다')  # 토핑이 존재하므로 출력됩니다.

# 오래된 두번째 토핑을 제거합니다.
fullPizza &= ~(1 << 1)
print(bin(fullPizza))  # 10101

# 네번째 토핑이 존재하면 제거하고 만약 없다면 새로 추가합니다. (토글)
fullPizza ^= (1 << 3)
print(bin(fullPizza))  # 11101

# 최소 원소 지우기
fullPizza &= (fullPizza - 1)
print(bin(fullPizza))  # 11100

# 모든 부분 집합 순회하기
"""
아래와 같은 순서로 출력됩니다.
0b0
0b1
0b10
0b11
0b100
0b101
0b110
0b111
"""
print("subset!!")
for subset in range(1 << 3):
    print(bin(subset))

```

## 참고자료

- https://stackoverflow.com/questions/9829578/fast-way-of-counting-non-zero-bits-in-positive-integer
- https://blog.naver.com/PostView.nhn?blogId=kmh03214&logNo=221702095617&parentCategoryNo=&categoryNo=23&viewDate=&isShowPopularPosts=true&from=search
