---
layout: post
cover: "assets/images/cover2.jpg"
navigation: True
title: BOJ 16988 - Baaaaaaaaaduk2 (Easy)
date: 2020-09-22
tags: BOJ
subclass: "post"
logo: "assets/images/ghost.png"
author: sohnjunior
categories: algorithm
comments: true
---

## ë¬¸ì œ

[ë°±ì¤€ ì˜¨ë¼ì¸ ì €ì§€ - 16988ë²ˆ](https://www.acmicpc.net/problem/16988)

## í’€ì´ ê³¼ì •

í°ëŒ 2ê°œë¥¼ ì‚¬ìš©í•´ì„œ ìµœëŒ€í•œ ë§ì€ ê²€ì€ ë°”ë‘‘ëŒì„ ì–»ëŠ” ë°©ë²•ì„ ì°¾ëŠ” ë¬¸ì œì…ë‹ˆë‹¤. <br>
ë¨¼ì € í°ëŒì„ ë†“ì„ í›„ë³´ì§€ë¥¼ ëª¨ë‘ ì°¾ì€ ë‹¤ìŒ, ì¡°í•©ì„ í†µí•´ 2ê°œ ìŒì„ êµ¬í•©ë‹ˆë‹¤. <br>
í°ëŒì€ ê²€ì€ëŒê³¼ ì¸ì ‘í•œ ìœ„ì¹˜ì— ë†“ì•„ì•¼ ì˜ë¯¸ê°€ ìˆê¸° ë•Œë¬¸ì— ì´ë¥¼ ê³ ë ¤í•˜ì—¬ íƒìƒ‰í•˜ë„ë¡ í•©ë‹ˆë‹¤. <br>
ê° ì„ íƒë§ˆë‹¤ `BFS` ë¥¼ í†µí•´ íšë“í•  ìˆ˜ ìˆëŠ” ê²€ì€ëŒì˜ ê°œìˆ˜ë¥¼ êµ¬í•˜ë©°, ê²€ì€ëŒì€ í°ëŒì´ë‚˜ ë²½ìœ¼ë¡œ ë‘˜ëŸ¬ì‹¸ì—¬ ìˆìœ¼ë©° ë¹ˆì¹¸ê³¼ ì¸ì ‘í•˜ë©´ ì•ˆë©ë‹ˆë‹¤. <br>
ê³„ì† `93%` ì—ì„œ ì‹œê°„ ì´ˆê³¼ê°€ ë°œìƒí•´ì„œ ê²€ì€ëŒì˜ ìœ„ì¹˜ë¥¼ ë¯¸ë¦¬ ê¸°ë¡í•´ë†“ëŠ” ë°©ë²•ë“¤ë„ ì‚¬ìš©í•´ë´¤ì§€ë§Œ í•´ê²°ì´ ë¶ˆê°€ëŠ¥í•˜ì—¬ ê²°êµ­ `pypy` ë¡œ ì œì¶œí–ˆìŠµë‹ˆë‹¤. ğŸ˜± <br>

## ì½”ë“œ

```python

import sys
from collections import deque
from itertools import combinations

N, M = list(map(int, sys.stdin.readline().split()))
board = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]

dx = [0, 0, 1, -1]
dy = [1, -1, 0, 0]

visit = []


def bfs(sx, sy):
    global visit
    stone, is_empty = 1, False
    q = deque()

    visit[sx][sy] = 1
    q.append([sx, sy])

    while q:
        x, y = q.popleft()

        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]
            if 0 <= nx < N and 0 <= ny < M:
                if not board[nx][ny]:
                    is_empty = True
                if not visit[nx][ny] and board[nx][ny] == 2:
                    q.append([nx, ny])
                    stone += 1
                    visit[nx][ny] = 1

    return stone if not is_empty else 0


def play(black_stone):
    global visit
    ret = 0
    visit = [[0]*M for _ in range(N)]

    for x, y in black_stone:
        if board[x][y] == 2 and not visit[x][y]:
            ret += bfs(x, y)

    return ret


def find_candidates():
    black, empty = [], []
    for x in range(N):
        for y in range(M):
            if board[x][y] == 2:
                black.append([x, y])
            if not board[x][y]:
                for i in range(4):
                    nx, ny = x + dx[i], y + dy[i]
                    if 0 <= nx < N and 0 <= ny < M and board[nx][ny] == 2:
                        empty.append([x, y])
                        break

    return black, empty


def solution():
    answer = 0
    black_stone, candidates = find_candidates()

    for picks in combinations(candidates, 2):
        board[picks[0][0]][picks[0][1]] = 1
        board[picks[1][0]][picks[1][1]] = 1
        answer = max(answer, play(black_stone))
        board[picks[0][0]][picks[0][1]] = 0
        board[picks[1][0]][picks[1][1]] = 0

    return answer


print(solution())

```
