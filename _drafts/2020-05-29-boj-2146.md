---
layout: post
title: BOJ 2146 - 다리 만들기
excerpt: "BOJ 2146 다리 만들기 with Python"
categories: [Algorithm]
tags: [Algorithm]
modified: 2020-05-29
comments: true
---

## 문제
[백준 온라인 저지 - 2146번](https://www.acmicpc.net/problem/2146)

## 풀이 과정


## 코드

~~~ python

import sys
from collections import deque

sys.setrecursionlimit(10**6)


N = int(input())
board = []
for _ in range(N):
    board.append(list(map(int, sys.stdin.readline().split())))


beaches = []
maps = [[0]*N for _ in range(N)]
dx = [0, 0, 1, -1]
dy = [1, -1, 0, 0]


def bfs():
    dist = [[0] * N for _ in range(N)]
    q = deque()
    for beach in beaches:
        dist[beach[0]][beach[1]] = 0
        q.append(beach)

    ans = sys.maxsize
    while q:
        x, y = q.popleft()

        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]
            if 0 <= nx < N and 0 <= ny < N:
                # 바다이면
                if maps[nx][ny] == 0:
                    # 아직 방문안했다면
                    if dist[nx][ny] == 0:
                        dist[nx][ny] = dist[x][y] + 1  # 거리 갱신
                        maps[nx][ny] = maps[x][y]  # 섬 확장
                        q.append([nx, ny])
                # 다음 지점이 다른 섬에 의해 이미 방문된 것이라면
                elif maps[nx][ny] != maps[x][y]:
                    ans = min(ans, dist[nx][ny]+dist[x][y])
    return ans


# 섬 구분해주기
def dfs(x, y, identify):
    global maps, beaches
    maps[x][y] = identify

    for i in range(4):
        nx, ny = x + dx[i], y + dy[i]
        if 0 <= nx < N and 0 <= ny < N:
            # 섬 내부일 경우
            if board[nx][ny] and maps[nx][ny] == 0:
                dfs(nx, ny, identify)
            # 해안가일 경우
            elif board[nx][ny] == 0:
                beaches.append([x, y])


def solution():
    identify = 1
    for r in range(N):
        for c in range(N):
            if maps[r][c] == 0 and board[r][c] != 0:
                dfs(r, c, identify)
                identify += 1

    answer = bfs()
    return answer


print(solution())

~~~
