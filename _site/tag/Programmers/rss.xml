<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>sohnjunior.github.io/</title>
   
   <link>http://localhost:4000</link>
   <description>PS와 웹 개발 관련내용을 기록합니다.</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>프로그래머스 Level 3 - 단어 변환</title>
	  <link>//pgs-wordchange</link>
	  <author></author>
	  <pubDate>2020-07-10T00:00:00+09:00</pubDate>
	  <guid>//pgs-wordchange</guid>
	  <description><![CDATA[
	     <h2 id="문제">문제</h2>

<p><a href="https://programmers.co.kr/learn/courses/30/lessons/43163">프로그래머스 - 단어 변환</a></p>

<h2 id="풀이-과정">풀이 과정</h2>

<p>시작 단어에서 목표 단어로 변형하는 최단 경로(비용)을 찾는 문제입니다. <br />
각 단어는 최대 한 문자만 변경이 가능하고 주어진 리스트에 포함된 단어일 경우에만 해당 단어로 변환을 시도해볼 수 있습니다. <br />
따라서 각 탐색마다 단어의 자리수를 하나씩 탐색하여 <code class="highlighter-rouge">a to z</code> 중 변환이 가능한 단어가 있는지 따져줍니다. <br />
이때 Python 에서는 <code class="highlighter-rouge">ord &amp; chr</code> 를 통해서 문자의 아스키코드 값을 활용할 수 있는데 문자열을 쉽게 처리하기 위해 활용하였습니다. <br />
또한 중복된 변환을 피하기 위해 <code class="highlighter-rouge">visit</code> 은 딕셔너리로 선언하여 <code class="highlighter-rouge">문자열 해싱</code> 을 통해 이미 변환을 시도했던 단어인지 효율적으로 판단하도록 했습니다. <br /></p>

<h2 id="코드">코드</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>


<span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">words</span><span class="p">):</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
    <span class="n">visit</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">words</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">here</span><span class="p">,</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">here</span> <span class="o">==</span> <span class="n">goal</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cost</span>

        <span class="c"># 각 자리를 순회하며 알파벳 하나를 변경해 만들 수 있는 단어를 탐색해봅니다.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">here</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s">'a'</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="s">'z'</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                    <span class="n">new_word</span> <span class="o">=</span> <span class="n">here</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="n">here</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="c"># 새로 만들어진 단어가 후보 리스트에 존재한다면</span>
                    <span class="k">if</span> <span class="n">new_word</span> <span class="ow">in</span> <span class="n">words</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visit</span><span class="p">[</span><span class="n">new_word</span><span class="p">]:</span>
                        <span class="n">visit</span><span class="p">[</span><span class="n">new_word</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">new_word</span><span class="p">,</span> <span class="n">cost</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">return</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">words</span><span class="p">):</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">bfs</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">words</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ans</span>

</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>프로그래머스 Level 2 - 타겟 넘버</title>
	  <link>//pgs-targetnum</link>
	  <author></author>
	  <pubDate>2020-07-10T00:00:00+09:00</pubDate>
	  <guid>//pgs-targetnum</guid>
	  <description><![CDATA[
	     <h2 id="문제">문제</h2>

<p><a href="https://programmers.co.kr/learn/courses/30/lessons/43165">프로그래머스 - 타겟 넘버</a></p>

<h2 id="풀이-과정">풀이 과정</h2>

<p>주어진 수에 덧셈과 뺄셈을 활용해서 목표 숫자를 만드는 문제입니다. <br />
최대 20개의 숫자를 사용하고 2가지 연산밖에 사용할 수 없으므로 최대 <code class="highlighter-rouge">2^20</code> 개의 상태를 방문하게 됩니다. <br />
이는 대략 <code class="highlighter-rouge">1000000</code> 으로 충분히 시간 내에 수행이 가능하므로 <code class="highlighter-rouge">DFS</code> 를 활용해 모든 경우의 수를 생성하여 가능한 방법의 수를 세어줬습니다. <br /></p>

<h2 id="코드">코드</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">here</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">depth</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">here</span> <span class="o">==</span> <span class="n">target</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="n">numbers</span><span class="p">[</span><span class="n">depth</span><span class="p">],</span> <span class="n">numbers</span><span class="p">[</span><span class="n">depth</span><span class="p">]]:</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">here</span> <span class="o">+</span> <span class="n">operand</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ans</span>

</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>프로그래머스 Level 3 - 네트워크</title>
	  <link>//pgs-network</link>
	  <author></author>
	  <pubDate>2020-07-10T00:00:00+09:00</pubDate>
	  <guid>//pgs-network</guid>
	  <description><![CDATA[
	     <h2 id="문제">문제</h2>

<p><a href="https://programmers.co.kr/learn/courses/30/lessons/43162">프로그래머스 - 네트워크</a></p>

<h2 id="풀이-과정">풀이 과정</h2>

<p>주어진 인접행렬을 기반으로 그래프 내의 컴포넌트 개수를 세는 문제입니다. <br />
각 정점별로 <code class="highlighter-rouge">DFS</code> 탐색을 통해 방문 가능한 모든 정점을 방문해주면 해당 정점이 속한 컴포넌트를 구할 수 있습니다. <br />
따라서 총 <code class="highlighter-rouge">DFS</code> 탐색이 몇번 수행되었는지 파악한다면 네트워크의 개수를 구할 수 있습니다. <br /></p>

<h2 id="코드">코드</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">adj</span><span class="p">,</span> <span class="n">visit</span><span class="p">,</span> <span class="n">here</span><span class="p">):</span>
    <span class="n">visit</span><span class="p">[</span><span class="n">here</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">there</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">adj</span><span class="p">[</span><span class="n">here</span><span class="p">][</span><span class="n">there</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visit</span><span class="p">[</span><span class="n">there</span><span class="p">]:</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">adj</span><span class="p">,</span> <span class="n">visit</span><span class="p">,</span> <span class="n">there</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">computers</span><span class="p">):</span>
    <span class="n">visit</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="n">network</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visit</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">computers</span><span class="p">,</span> <span class="n">visit</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">network</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">network</span>

</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>프로그래머스 Level 3 - 최고의 집합</title>
	  <link>//pgs-bestset</link>
	  <author></author>
	  <pubDate>2020-07-10T00:00:00+09:00</pubDate>
	  <guid>//pgs-bestset</guid>
	  <description><![CDATA[
	     <h2 id="문제">문제</h2>

<p><a href="https://programmers.co.kr/learn/courses/30/lessons/12938">프로그래머스 - 최고의 집합</a></p>

<h2 id="풀이-과정">풀이 과정</h2>

<p>자연수 n 개를 사용해서 총합이 S가 되며 동시에 각 원소의 곱이 최대인 집합을 <code class="highlighter-rouge">최고의 집합</code> 이라고 표현합니다. <br />
입력으로 주어지는 합 S가 1억이고 자연수 n의 개수는 최대 10,000 이기 때문에 모든 조합을 만들어보는 방법은 시간내에 수행이 불가능합니다. <br /><br /></p>

<p>좀 더 효율적인 방법은 없을까요? 바로 <code class="highlighter-rouge">탐욕적인 선택</code> 으로 최적의 답을 구할 수 있습니다. 이를 증명하기 위해 다음과 같이 생각해봤습니다. <br />
우선 총 k 개의 j 합이 S 를 만족한다고 가정하겠습니다. <br /></p>

<p>j j j … j =&gt; 총 k 개이며 합이 S, 따라서 j*k = S</p>

<p>합이 S가 되는 숫자의 조합은 상당히 다양하므로 이번에는 j에 임의의 양의 정수 l 만큼 값이 차이가 나는 경우를 따져보겠습니다. <br /></p>

<p>j-l j j j …. j+l =&gt; 합은 여전히 S</p>

<p>이 경우 모든 원소의 합이 S 이기 때문에 한 원소에서 l 만큼 감소했으므로 다른 원소에서 l 만큼 값이 더해졌을 것입니다. <br />
그렇다면 모든 원소를 곱했을 경우 어떻게 될까요? <br />
기존에는 <code class="highlighter-rouge">j*k</code> 였지만 두 원소의 값이 달라져서 <code class="highlighter-rouge">(j-l)(j+l)(j*(k-2))</code> 가 되었습니다. <br />
따라서 차이가 발생하는 두 원소만 비교하자면 <code class="highlighter-rouge">j^2-l^2 &lt; j^2</code> 이기 때문에 모든 값이 균등한 첫 번째 경우가 모든 원소의 곱이 더 크다는 것을 알 수 있습니다. <br />
그러므로 최고의 집합을 찾기 위해서는 <code class="highlighter-rouge">모든 원소를 최대한 균등하게 분배해줘야한다</code> 라는 사실을 알 수 있습니다. <br /></p>

<p>코드로 구현할때는 S를 n으로 나눈 몫을 n 개 만큼 할당한 뒤 S 에서 n을 나눴을때 발생한 나머지 값을 각 원소에 균등하게 나눠주면 됩니다. <br />
구현 코드 자체는 짧았지만 많은 것을 생각해볼 수 있는 문제였습니다. <br /></p>

<h2 id="코드">코드</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">quo</span><span class="p">,</span> <span class="n">remain</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="p">[</span><span class="n">quo</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="c"># 나머지를 균등하게 분배한다</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">remain</span><span class="p">):</span>
        <span class="n">answer</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">answer</span>

</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>프로그래머스 Level 2 - 큰 수 만들기</title>
	  <link>//pgs-bignum</link>
	  <author></author>
	  <pubDate>2020-07-03T00:00:00+09:00</pubDate>
	  <guid>//pgs-bignum</guid>
	  <description><![CDATA[
	     <h2 id="문제">문제</h2>

<p><a href="https://programmers.co.kr/learn/courses/30/lessons/42883">프로그래머스 - 큰 수 만들기</a></p>

<h2 id="풀이-과정">풀이 과정</h2>

<p>k 개의 숫자를 제거하여 만들 수 있는 수 중에서 가장 큰 수를 찾는 문제입니다. <br />
만약 <code class="highlighter-rouge">브루트 포스</code> 로 접근해 모든 조합을 만들어 본다면 최대 문자열의 길이 때문에 시간내에 수행이 불가능합니다. <br />
대신에 큰 수를 구성하기 위한 조건으로 각 숫자를 <code class="highlighter-rouge">탐욕적인 선택</code> 에 따라 제거해준다면 선형 시간내에 수행이 가능합니다. <br /><br /></p>

<p>이를 위해서는 <code class="highlighter-rouge">탐욕적인 선택</code> 에 따라 우리가 절대 손해보는 일이 없음을 증명해야합니다. <br />
어떤 숫자가 가장 큰 수가 되기 위해서는 가장 높은 자리수부터 큰 수를 가져야함은 자명합니다. <br />
따라서 우리는 큰 자리수 부터 탐색을 수행하며 (인덱스로 따지면 0 부터) 가장 큰 수가 되기 위한 각 숫자들의 정당성을 따져도록 합니다. <br />
어떤 수를 제거한다는 의미는 제거되는 숫자 다음 자리수가 해당 자리수를 대체한다는 의미입니다. <br />
따라서 숫자가 제거된 후 전체 자리수가 하나 줄어든 상황에서 가장 큰 수를 유지하기 위해서는 제거되는 숫자 다음에 오는 수가 해당 수보다 커야합니다. <br />
그러므로 <code class="highlighter-rouge">스택</code> 을 통해 각 자리수를 저장하면서 현재 <code class="highlighter-rouge">top</code> 에 존재하는 수보다 큰 수가 입력으로 들어올 경우 <code class="highlighter-rouge">pop</code> 연산을 통해 <code class="highlighter-rouge">top</code> 에는 항상 가장 큰 수가 유지되도록 해줍니다. <br />
이때 <code class="highlighter-rouge">pop</code> 되는 횟수가 목표 제거 횟수에 미치지 못할 경우 현재 숫자는 내림차순으로 구성되어있기 때문에 뒷 자리부터 부족한 개수 만큼 제거해주면 되는 것입니다. <br /></p>

<h2 id="코드">코드</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pop_count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">number</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">stack</span> <span class="ow">or</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">num</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">pop_count</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="ow">and</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">pop_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">pop_count</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">pop_count</span><span class="p">):</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">return</span> <span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span>


<span class="n">number</span> <span class="o">=</span> <span class="s">'1924'</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>

<span class="k">print</span><span class="p">(</span><span class="n">solution</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>  <span class="c"># 94</span>

</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>프로그래머스 Level 3 - 섬 연결하기</title>
	  <link>//pgs-island</link>
	  <author></author>
	  <pubDate>2020-05-14T00:00:00+09:00</pubDate>
	  <guid>//pgs-island</guid>
	  <description><![CDATA[
	     <h2 id="문제">문제</h2>

<p><a href="https://programmers.co.kr/learn/courses/30/lessons/42861">프로그래머스 - 섬 연결하기</a></p>

<h2 id="풀이-과정">풀이 과정</h2>

<p>모든 정점을 연결하는 최소 신장 트리(MST)를 구하는 문제이다. <br />
프림과 크루스칼 알고리즘을 활용할 수 있는데 이번에는 크루스칼을 사용했다. <br />
크루스칼 알고리즘은 간선 정보들을 오름차순으로 정렬해준 다음, 사이클을 형성하지 않는 간선들을 탐욕적으로 선택해준다. <br />
이를 위한 union-find 자료구조만 신경써서 구현하면 무난히 풀 수 있는 문제이다. <br /></p>

<h2 id="코드">코드</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">u</span><span class="p">),</span> <span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">p</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>


<span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="n">u</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">u</span>
    <span class="n">p</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="n">u</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">kruskal</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
    <span class="n">edges</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="c"># 이미 같은 컴포넌트라면 pass</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">union</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">answer</span> <span class="o">+=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">answer</span>


<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">costs</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="n">kruskal</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">costs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">answer</span>


<span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">costs</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
<span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">costs</span><span class="p">))</span>

</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>프로그래머스 Level 4 - 게임 맵 최단거리</title>
	  <link>//pgs-gamemap</link>
	  <author></author>
	  <pubDate>2020-05-13T00:00:00+09:00</pubDate>
	  <guid>//pgs-gamemap</guid>
	  <description><![CDATA[
	     <h2 id="출처">출처</h2>

<p><a href="https://programmers.co.kr/learn/courses/30/lessons/43238">프로그래머스 - 게임 맵 최단거리</a></p>

<h2 id="문제">문제</h2>

<p>ROR 게임은 두 팀으로 나누어서 진행하며, 상대 팀 진영을 먼저 파괴하면 이기는 게임입니다. <br />
따라서, 각 팀은 상대 팀 진영에 최대한 빨리 도착하는 것이 유리합니다. <br /></p>

<p>지금부터 당신은 한 팀의 팀원이 되어 게임을 진행하려고 합니다. <br />
다음은 5 x 5 크기의 맵에, 당신의 캐릭터가 (행: 1, 열: 1) 위치에 있고, 상대 팀 진영은 (행: 5, 열: 5) 위치에 있는 경우의 예시입니다. <br /></p>

<p><img src="/assets/images/programmers/gamemap.png" alt="이미지" width="170" /></p>

<p>위 그림에서 검은색 부분은 벽으로 막혀있어 갈 수 없는 길이며, 흰색 부분은 갈 수 있는 길입니다. <br />
캐릭터가 움직일 때는 동, 서, 남, 북 방향으로 한 칸씩 이동하며, 게임 맵을 벗어난 길은 갈 수 없습니다. <br />
만약, 상대 팀이 자신의 팀 진영 주위에 벽을 세워두었다면 상대 팀 진영에 도착하지 못할 수도 있습니다. <br />
게임 맵의 상태 maps가 매개변수로 주어질 때, 캐릭터가 상대 팀 진영에 도착하기 위해서 지나가야 하는 칸의 개수의 최솟값을 return 하도록 solution 함수를 완성해주세요. <br />
단, 상대 팀 진영에 도착할 수 없을 때는 -1을 return 해주세요. <br /></p>

<h2 id="풀이-과정">풀이 과정</h2>

<p><code class="highlighter-rouge">BFS</code> 를 통해 목표지점까지의 최단 거리를 탐색하는 문제이다. <br />
방문여부와 거리 정보를 저장히기 위해서 딕셔너리 자료형을 사용할수도 있지만 게임맵과 동일한 이차원 배열을 선언해서 <br />
-1일 경우는 아직 방문하지 않은 지점, 그 외의 경우는 이미 방문해서 최단 경로를 구한 지점으로 판단하도록 했다. <br />
이렇게 하면 트리 탐색시간을 절약할 수 있어서 더 빠른 수행시간을 가지게 된다. <br /></p>

<h2 id="코드">코드</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>


<span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">dy</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">maps</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">maps</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

    <span class="n">dist</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
    <span class="n">goal</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="n">dist</span><span class="p">[</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">here</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">here</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">goal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">here</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">goal</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">dist</span><span class="p">[</span><span class="n">here</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">here</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="n">next_x</span><span class="p">,</span> <span class="n">next_y</span> <span class="o">=</span> <span class="n">here</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">here</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">next_x</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">next_y</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">maps</span><span class="p">[</span><span class="n">next_x</span><span class="p">][</span><span class="n">next_y</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dist</span><span class="p">[</span><span class="n">next_x</span><span class="p">][</span><span class="n">next_y</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">dist</span><span class="p">[</span><span class="n">next_x</span><span class="p">][</span><span class="n">next_y</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">here</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">here</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">next_x</span><span class="p">,</span> <span class="n">next_y</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>


<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">maps</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="n">bfs</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">answer</span>


<span class="n">maps</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="k">print</span><span class="p">(</span><span class="n">solution</span><span class="p">(</span><span class="n">maps</span><span class="p">))</span>

</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>프로그래머스 Level 3 - 입국 심사</title>
	  <link>//pgs-immegration</link>
	  <author></author>
	  <pubDate>2020-05-08T00:00:00+09:00</pubDate>
	  <guid>//pgs-immegration</guid>
	  <description><![CDATA[
	     <h2 id="출처">출처</h2>

<p><a href="https://programmers.co.kr/learn/courses/30/lessons/43238">프로그래머스 - 입국 심사</a></p>

<h2 id="문제">문제</h2>

<p><code class="highlighter-rouge">n</code> 명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다. <br /></p>

<p>처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. <br />
가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. <br />
하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다. <br /></p>

<p>모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다. <br /></p>

<p>입국심사를 기다리는 사람 수 <code class="highlighter-rouge">n</code>, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 <code class="highlighter-rouge">times</code> 가 매개변수로 주어질 때, <br />
모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요. <br /></p>

<h2 id="풀이-과정">풀이 과정</h2>

<p>이 문제는 입력값이 매우 크게 주어져 있기 때문에 일반적인 방법으로 탐색을 수행하면 타임 아웃이 발생하므로 다른 방법이 필요합니다. <br /><br /></p>

<p>효율성을 고려하지 않고 처음 떠올린 해법은 <code class="highlighter-rouge">times</code> 배열과 크기가 같은 <code class="highlighter-rouge">jobs</code> 배열을 생성한 뒤, 해당 배열에는 현재 손님의 업무가 끝나는 시간을 기록하고 <br />
다음번 손님의 입국 심사대를 고를때는 각 심사대의 시간을 <code class="highlighter-rouge">jobs</code> 배열에 각각 더해본 다음 가장 짧은 심사대로 배치시키는 것입니다. <br />
하지만 이 방법은 배열의 크기에 비례하여 시간 복잡도가 증가하므로 보다 효울적인 탐색을 위해 <code class="highlighter-rouge">이진 탐색</code> 을 활용하기로 했습니다. <br /></p>

<p>최악의 경우 소요되는 시간은 얼마일까요? 그건 바로 모든 손님이 가장 느린 심사대에서 심사를 받는 것입니다. <br />
따라서 <code class="highlighter-rouge">hi</code> 를 이 값으로 설정해준 다음, <code class="highlighter-rouge">mid</code> 에 해당하는 시간에 손님을 전부 감당할 수 있다면 탐색 범위를 더 작은 쪽으로, <br />
만약 감당이 불가능하다면 탐색 범위를 더 큰 쪽으로 옮겨서 최적의 시간을 찾아냈습니다. <br /></p>

<p>이때 주어진 시간에 손님을 전부 처리할 수 있는지 확인하는 과정에서는 각 심사관마다 주어진 시간 내에 처리할 수 있는 손님의 수를 합해서 <br />
목표 손님수에 도달했다면 바로 <code class="highlighter-rouge">True</code> 를 반환하도록 하여 불필요한 탐색 시간을 줄였습니다. <br /></p>

<h2 id="코드">코드</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">can_work</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">due</span><span class="p">,</span> <span class="n">goal</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">times</span><span class="p">:</span>
        <span class="n">goal</span> <span class="o">-=</span> <span class="p">(</span><span class="n">due</span> <span class="o">//</span> <span class="n">time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">goal</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>


<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">lo</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">hi</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">can_work</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="n">mid</span>
            <span class="n">hi</span> <span class="o">=</span> <span class="n">mid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lo</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">answer</span>


<span class="n">n</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">times</span><span class="p">))</span>  <span class="c"># 답은 28</span>

</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>프로그래머스 Level 3 - 추석 트래픽</title>
	  <link>//pgs-holiday-traffic</link>
	  <author></author>
	  <pubDate>2020-05-03T00:00:00+09:00</pubDate>
	  <guid>//pgs-holiday-traffic</guid>
	  <description><![CDATA[
	     <h2 id="출처">출처</h2>

<p><a href="https://programmers.co.kr/learn/courses/30/lessons/17676">프로그래머스 - 추석 트래픽</a></p>

<h2 id="문제">문제</h2>

<p>이번 추석에도 시스템 장애가 없는 명절을 보내고 싶은 어피치는 서버를 증설해야 할지 고민이다. <br />
장애 대비용 서버 증설 여부를 결정하기 위해 작년 추석 기간인 9월 15일 로그 데이터를 분석한 후 초당 최대 처리량을 계산해보기로 했다. <br />
초당 최대 처리량은 요청의 응답 완료 여부에 관계없이 임의 시간부터 1초(=1,000밀리초)간 처리하는 요청의 최대 개수를 의미한다. <br /></p>

<p><img src="/assets/images/programmers/holiday-traffic.png" alt="이미지" width="300" />
위의 타임라인 그림에서 빨간색으로 표시된 1초 각 구간의 처리량을 구해보면 (1)은 4개, (2)는 7개, (3)는 2개임을 알 수 있다. <br />
따라서 초당 최대 처리량은 7이 되며, 동일한 최대 처리량을 갖는 1초 구간은 여러 개 존재할 수 있으므로 이 문제에서는 구간이 아닌 개수만 출력한다. <br /></p>

<h2 id="풀이-과정">풀이 과정</h2>

<p>주어진 문자열을 적절히 변환한 뒤 일정 크기의 윈도우와 최대한 많이 겹치는 트래픽의 수를 구하면 된다. <br /></p>

<h3 id="문자열-처리하기">문자열 처리하기</h3>

<p>밀리세컨드 단위의 시간 계산은 처음이라서 어떻게 해줘야할지 고민하다가 <code class="highlighter-rouge">float</code> 형으로 변환하여 사용하면 효율적일 것 같아서 이 방법을 사용했다. <br />
다만 전날부터 트래픽이 시작 되었을 경우 <code class="highlighter-rouge">트래픽 종료 시간 - 소요된 시간</code>이 음수가 되는 경우가 있어서 이 부분에 대한 예외처리는 따로 해줘야 했다. <br /></p>

<p>또한 <code class="highlighter-rouge">float</code>형으로 변환하고 산술연산을 수행하면 소수점 자리에 예상하지 못한 값들이 출력되는 경우가 있어서 <br />
<code class="highlighter-rouge">round</code> 함수를 통해 소수점 자리수를 고정시켜주는 작업이 필요했다. <br /></p>

<h3 id="최대-처리량-계산하기">최대 처리량 계산하기</h3>

<p>최대 처리량을 구하는 부분이 예상보다 좀 까다로웠다. <br />
처음에는 첫 트래픽을 기준으로 <code class="highlighter-rouge">밀리세컨드 단위</code>로 윈도우를 증가시키면서 전체 탐색을 수행했지만 <code class="highlighter-rouge">시간초과</code>가 발생했다.<br />
최적화를 위해 Greedy한 방법으로 접근해서 끝나는 시간을 기준으로 트래픽 갯수를 체크하려고 했지만 <br />
이 경우에 검사를 못하고 지나치는 부분이 있어서 몇 가지 테스트케이스에 대해 잘못된 결과를 출력함에 따라 다른 방법이 필요했다. <br /></p>

<p>도무지 최적화 방법이 떠오르지 않아 카카오 문제 해설을 참고하여 트래픽이 새로 들어오거나 끝나는 부분에서만 <br />
윈도우와 겹치는 트래픽 갯수를 세어주면 된다는 것을 알게 되었다. <br /></p>

<p>문제를 차근차근 따져보는 연습이 아직 많이 필요한 것 같다. <br /></p>

<h2 id="코드">코드</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="c"># 시작시간과 끝나는 시간을 반환</span>
<span class="k">def</span> <span class="nf">parse_time</span><span class="p">(</span><span class="n">traffic_change</span><span class="p">,</span> <span class="n">time_str</span><span class="p">):</span>
    <span class="n">end</span><span class="p">,</span> <span class="n">duration</span> <span class="o">=</span> <span class="n">time_str</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">duration</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">duration</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'s'</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">end_h</span><span class="p">,</span> <span class="n">end_m</span><span class="p">,</span> <span class="n">end_s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">end</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">':'</span><span class="p">)))</span>

    <span class="n">end</span> <span class="o">=</span> <span class="mi">3600</span> <span class="o">*</span> <span class="n">end_h</span> <span class="o">+</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">end_m</span> <span class="o">+</span> <span class="n">end_s</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">duration</span> <span class="o">+</span> <span class="mf">0.001</span>
    <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">traffic_change</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">traffic_change</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">traffic_change</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">timeline</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="n">timeline</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parse_time</span><span class="p">(</span><span class="n">traffic_change</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>

    <span class="c"># 끝나는 시간으로 오름차순 정렬 - 시작하는 시간으로 정렬해도 상관 없을 듯 하다.</span>
    <span class="n">timeline</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">traffic_change</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">point</span>
        <span class="n">window_end</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">window</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mf">0.001</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="n">hit</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">traffic</span> <span class="ow">in</span> <span class="n">timeline</span><span class="p">:</span>
            <span class="n">traffic_start</span> <span class="o">=</span> <span class="n">traffic</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">traffic_end</span> <span class="o">=</span> <span class="n">traffic</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c"># 현재 window 에 해당하지 않는다면</span>
            <span class="k">if</span> <span class="n">traffic_start</span> <span class="o">&gt;</span> <span class="n">window_end</span> <span class="ow">or</span> <span class="n">traffic_end</span> <span class="o">&lt;</span> <span class="n">window</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">traffic</span><span class="p">)</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">answer</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">hit</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">answer</span>


<span class="n">lines</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">"2016-09-15 20:59:57.421 0.351s"</span><span class="p">,</span>
    <span class="s">"2016-09-15 20:59:58.233 1.181s"</span><span class="p">,</span>
    <span class="s">"2016-09-15 20:59:58.299 0.8s"</span><span class="p">,</span>
    <span class="s">"2016-09-15 20:59:58.688 1.041s"</span><span class="p">,</span>
    <span class="s">"2016-09-15 20:59:59.591 1.412s"</span><span class="p">,</span>
    <span class="s">"2016-09-15 21:00:00.464 1.466s"</span><span class="p">,</span>
    <span class="s">"2016-09-15 21:00:00.741 1.581s"</span><span class="p">,</span>
    <span class="s">"2016-09-15 21:00:00.748 2.31s"</span><span class="p">,</span>
    <span class="s">"2016-09-15 21:00:00.966 0.381s"</span><span class="p">,</span>
    <span class="s">"2016-09-15 21:00:02.066 2.62s"</span>
<span class="p">]</span>

<span class="k">print</span><span class="p">(</span><span class="n">solution</span><span class="p">(</span><span class="n">lines</span><span class="p">))</span>  <span class="c"># 결과는 7</span>


</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>프로그래머스 Level 3 - 블록 이동하기</title>
	  <link>//pgs-block</link>
	  <author></author>
	  <pubDate>2020-05-01T00:00:00+09:00</pubDate>
	  <guid>//pgs-block</guid>
	  <description><![CDATA[
	     <h2 id="출처">출처</h2>

<p><a href="https://programmers.co.kr/learn/courses/30/lessons/60063">프로그래머스 - 블록 이동하기</a></p>

<h2 id="문제">문제</h2>

<p><img src="/assets/images/programmers/block.jpg" alt="이미지" width="300" />
<br />
무지는 <code class="highlighter-rouge">N×N</code>크기의 지도 위에서 <code class="highlighter-rouge">2×1</code>크기의 로봇을 이동하여 목표지점에 도달할 수 있도록 프로그램을 구현하고자 한다. <br />
로봇은 항상 <code class="highlighter-rouge">(1,1)</code>에서 시작하며 로봇이 차지하고 있는 칸중 어느 하나라도 <code class="highlighter-rouge">(N,N)</code>위치에 도달하면 된다. <br />
로봇이 움직일때는 현재 상태를 유지하며 이동하고 다음 조건에 따라 90도씩 회전 연산도 가능하다. <br /><br /><br /></p>

<p><img src="/assets/images/programmers/block-rotate.jpg" alt="이미지" width="300" />
<br />
0과 1로 이루어진 지도인 board가 주어질 때, 로봇이 <code class="highlighter-rouge">(N,N)</code> 위치까지 이동하는데 필요한 최소 시간을 return 하도록 solution 함수를 완성하라.</p>

<h2 id="풀이-과정">풀이 과정</h2>

<p>로봇이 이동할 수 있는 모든 경우를 따져보며 탐색을 수행하면 된다. <br />
최단 경로를 찾으면 바로 탐색을 종료하면되므로 같은 depth의 상태들을 탐색하기 위해 <code class="highlighter-rouge">BFS</code>를 사용했다. <br /></p>

<p>다만 로봇의 상태와 회전 연산을 구현하는 부분이 매우 까다로웠다..</p>

<h3 id="로봇의-상태-나타내기">로봇의 상태 나타내기</h3>

<p>처음에는 <code class="highlighter-rouge">board</code>에 로봇의 상태를 표시해주며 이를 탐색에 활용하였지만 얼마 지나지 않아 이 방법이 굉장히 비효율적이라는 것을 알게 되었다. <br />
어차피 <code class="highlighter-rouge">board</code>는 고정이고 우리는 로봇의 위치만 변경시키면서 탐색을 수행하면 되므로 <code class="highlighter-rouge">board</code> 대신 로봇의 죄표값을 통해 탐색을 수행하도록 하였다.<br /></p>

<blockquote>
  <p>문제 풀이 후 다른 사람들의 코드도 봤는데 <code class="highlighter-rouge">visited</code> 배열을 따로 유지하고 Queue에 걸린 시간을 좌표값과 함께 넣어준 것이 인상적이었다. <br /> 이렇게 하면 hashable 객체로 바꿔서 딕셔너리에 넣으려고 굳이 list를 tuple로 변경하지 않아도 될 것 같다.</p>
</blockquote>

<h3 id="로봇-회전시키기">로봇 회전시키기</h3>

<p>이번 문제에서 가장 까다로웠던 회전 연산을 구현하기 위해서는 상,하,좌,우 이동과 4가지의 회전 연산을 모두 체크해줘야한다.</p>

<p>상하좌우 좌표값들을 검사하는건 다른 문제들과 다른 것이 없지만 회전 연산이 가능한지는 어떻게 알 수 있을까? <br /></p>

<p>생각해보면 회전 연산을 위해서는 회전하고 싶은 방향이 무조건 모두 비어있는 상태여야 한다는 것을 알 수 있다.<br />
아래와 같이 한군데라도 벽이 있다면 그 쪽으로는 회전이 불가능하다.<br /><br />
<img src="/assets/images/programmers/block-example.png" alt="이미지" width="300" /></p>

<p>따라서 나는 이전에 상,하,좌,우 중에서 이동이 가능했던 연산들을 저장해놓은 다음, 그에 맞는 회전 죄표값들을 생성해줬다. <br /></p>

<blockquote>
  <p>이때 주의할 점은 나의 구현 방식을 기준으로 회전된 좌표값은 로봇의 두 좌표중 항상 왼쪽 or 상단의 좌표가 먼저 나오도록 생성해줘야 한다는 것이다. <br />이거 때문에 처음에 계속 실패했었다..</p>
</blockquote>

<h2 id="코드">코드</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>


<span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">dy</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">here</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">)</span>
    <span class="n">movable</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">movable_dir</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># 이동 가능한 방향</span>
    <span class="c"># 상하좌우</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="nb">next</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="nb">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">here</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="nb">next</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">here</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="nb">next</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">here</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="nb">next</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">here</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">N</span> <span class="ow">or</span> <span class="nb">next</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">next</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="nb">next</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">next</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">N</span> <span class="ow">or</span> <span class="nb">next</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">next</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="nb">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="nb">next</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">board</span><span class="p">[</span><span class="nb">next</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="nb">next</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">movable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">next</span><span class="p">))</span>
        <span class="n">movable_dir</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="c"># 회전</span>
    <span class="n">axis1</span> <span class="o">=</span> <span class="n">here</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">axis2</span> <span class="o">=</span> <span class="n">here</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>

    <span class="c"># 가로로 놓여있을 경우</span>
    <span class="k">if</span> <span class="n">axis1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">axis2</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="c"># 아래가 다 비어서 이동 가능할 경우</span>
        <span class="k">if</span> <span class="mi">2</span> <span class="ow">in</span> <span class="n">movable_dir</span><span class="p">:</span>
            <span class="n">there1</span> <span class="o">=</span> <span class="n">axis1</span> <span class="o">+</span> <span class="p">(</span><span class="n">axis2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">there2</span> <span class="o">=</span> <span class="n">axis2</span> <span class="o">+</span> <span class="p">(</span><span class="n">axis1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">movable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">there1</span><span class="p">)</span>
            <span class="n">movable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">there2</span><span class="p">)</span>
        <span class="c"># 위에가 다 비어서 이동 가능할 경우</span>
        <span class="k">if</span> <span class="mi">3</span> <span class="ow">in</span> <span class="n">movable_dir</span><span class="p">:</span>
            <span class="n">there1</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">axis1</span>
            <span class="n">there2</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">axis2</span>
            <span class="n">movable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">there1</span><span class="p">)</span>
            <span class="n">movable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">there2</span><span class="p">)</span>
    <span class="c"># 세로로 놓여있을 경우</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># 오른쪽이 다 비어서 이동 가능할 경우</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">movable_dir</span><span class="p">:</span>
            <span class="n">there1</span> <span class="o">=</span> <span class="n">axis1</span> <span class="o">+</span> <span class="p">(</span><span class="n">axis2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">there2</span> <span class="o">=</span> <span class="n">axis2</span> <span class="o">+</span> <span class="p">(</span><span class="n">axis1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">movable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">there1</span><span class="p">)</span>
            <span class="n">movable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">there2</span><span class="p">)</span>
        <span class="c"># 왼쪽이 다 비어서 이동 가능할 경우</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">movable_dir</span><span class="p">:</span>
            <span class="n">there1</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">axis1</span>
            <span class="n">there2</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">axis2</span>
            <span class="n">movable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">there1</span><span class="p">)</span>
            <span class="n">movable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">there2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">movable</span>


<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>
    <span class="c"># 처음 로봇 위치</span>
    <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">)</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c"># 걸린 시간</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

    <span class="n">cost</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">here</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">here</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">here</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">here</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">here</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="n">cost</span><span class="p">[</span><span class="n">here</span><span class="p">]</span>
            <span class="k">break</span>

        <span class="n">move_list</span> <span class="o">=</span> <span class="n">move</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">here</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">there</span> <span class="ow">in</span> <span class="n">move_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">there</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cost</span><span class="p">:</span>
                <span class="n">cost</span><span class="p">[</span><span class="n">there</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span><span class="p">[</span><span class="n">here</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">there</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">answer</span>


<span class="n">board</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="k">print</span><span class="p">(</span><span class="n">solution</span><span class="p">(</span><span class="n">board</span><span class="p">))</span>  <span class="c"># 결과는 7</span>

</code></pre></div></div>

	  ]]></description>
	</item>


</channel>
</rss>
